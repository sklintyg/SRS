= SRS (Stöd för Rätt Sjukskrivning)

== Runtime

To get the application up and running, you have to do three things in preparation:

=== Install R

R is used for prediction modelling, and the 'rJava' package is used as the bridge between Java and R.

Install a recent version of R, using your package manager of choice. R packages have been tried with Mac Homebrew, Arch Linux and CentOS.

Install 'rJava' and 'pch' into the R environment. This is most easily done by logging in to R (i.e. start 'R' from the command line) and then run the
lines:
----
install.packages("rJava")
install.packages("pch")
----

Now you need to figure out things: where your R environment has been installed, and where the rJava package has been installed.

On Mac OS using Homebrew, it's probably:
----
R_HOME=/Library/Frameworks/R.framework/Resources
java.library.path=/Library/Frameworks/R.framework/Resources/library/rJava/jri
----

On Arch Linux, it's probably:
----
R_HOME=/usr/lib64/R
java.library.path="$HOME/R/x86_64-pc-linux-gnu-library/3.4/rJava/jri"
----

On CentOS, it's probably:
----
R_HOME=/usr/lib64/R
java.library.path=/usr/lib64/R/library/rJava/jri
----

These values will be used when the srs application is started, but first:


=== Compile schemas

Since we're still in quite rapid development, srs relies on a snapshot version of the intyg schemas, and therefore you need to build and
install the latest version of these into your local maven repo:

In schemas/intyg/clinicalprocess-healthcond-srs:

 ./gradlew clean build install


=== R models 

R models for testing purposes are checked-in into version control, and can be found at srs/src/main/resources/model.

=== Building and running the application

Now that the dependencies are taken care of, we build the application as usual:

 ./gradlew clean build

To run the application run the following, substituting your values for R_HOME and java.library.path:

 R_HOME=/Library/Frameworks/R.framework/Resources java -Djava.library.path="/Library/Frameworks/R.framework/Resources/library/rJava/jri" -Dsrs.resources.folder="[SRS-project]/src/main/resources" -jar build/libs/*.war --spring.profiles.active=runtime,it

Replace [SRS-project] with your local SRS-project directory
The 'runtime' profile is necessary to make sure that a real connection to the R engine is created.
The 'it' profile is needed to enable the testability api (used in restAssured integration tests).


=== SoapUI

There is a SoapUI in the project repository which can be used to fire test messages at the application once it's running. Import the file
soapui/GetSRSInformation-soapui-project.xml into your SoapUI and try it.

== Run with docker (with pre-installed java and R)
To run with docker, first build schemas according to instructions above, then use the following commands:

1) host, from srs directory

----
./gradlew clean build
docker run -it -e TZ=Europe/Stockholm -p 8080:8080 -v <complete_path_to_srs_folder_in_host_os>:/srs --entrypoint=/bin/bash jaehyeon/r-java
----

Note that the timezone environment variable is required due to integrations tests that make an assumption that the timezone host and the container is the same. If timezone of the host is not Europe/Stockholm, change the timezone variable accordingly.


2) container

----
/usr/bin/R
install.packages("pch")
40
quit()
n
cd /srs
R_HOME=/usr/lib/R java -Djava.library.path="/usr/local/lib/R/site-library/rJava/jri" -Dsrs.resources.folder="/srs/src/main/resources" -jar build/libs/*.war --spring.profiles.active=runtime,it
----

== H2

When running locally (without the mysql profile), a H2 database is used, and a console to the database servier is automatically started. It
is available at:

http://localhost:8080/h2-console/

Within the console, specify this address to connect to the database: 'jdbc:h2:mem:testdb'


== Ansible

The ansible provisioning is similar to all other intygsprojekt-services: the baseline provisioning is found in the 'tools' git repo. In the
srs repo, the ansible provision/deploy is in the file site.yml.

Here's an example of running the 'site.yml' for provisioning to test, using what you've built on your local machine:

 ansible-playbook -i inventory/srs/test site.yml -e "gitcrypt_key_file=/opt/key/git-crypt4.key gitcrypt_key_name=git-crypt4.key" -e "version=0.0.1-SNAPSHOT" -e "deploy_from_repo=false"


== GNU Awk

  ssconvert -S ~/Downloads/SRS_PM_FrågorOchSvar.xlsx /tmp/fragor.csv

  cat /tmp/fragor.csv.0 | sed '1d' | awk 'BEGIN { FPAT = "([^,]+)|(\"[^\"]+\")" } { print "val question"NR" = questionRepo.save(PredictionQuestion("NR", "$1", "$2", \""$3"\", listOf()))" }'
  cat /tmp/fragor.csv.1 | sed '1d' | awk 'BEGIN { FPAT = "([^,]+)|(\"[^\"]+\")" } { print "responseRepo.save(PredictionResponse("NR", \""$2"\", \""$3"\", "tolower($4)", "$5")) // "$1 }'
  cat /tmp/fragor.csv.2 | sed '1d' | awk -F, 'BEGIN { countD = 0 } { if ($1 != lastD) { countD += 1; countP = 1; printf ")))\ndiagnosisRepo.save(PredictionDiagnosis("countD", \""$1"\", listOf(predictPrioRepo.save(PredictionPriority("countP", "$2"))" } else { countP += 1; printf ", predictPrioRepo.save(PredictionPriority("countP", "$2"))" }; lastD = $1 } END { print ")))" }'
